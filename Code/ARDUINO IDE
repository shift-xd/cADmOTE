#include <Arduino.h>
#include <Wire.h>
#include <BleMouse.h>

// Pin definitions for XIAO RP2040
// Assuming standard I2C pins for accelerometer
#define ACCEL_SDA 0
#define ACCEL_SCL 1

// Button pins (adjust based on your PCB)
#define BTN_ROTATE 2
#define BTN_PAN 3
#define BTN_ZOOM 4
#define BTN_RESET 5
#define BTN_MODE 6

// Accelerometer (LIS3DH or similar)
#define ACCEL_ADDR 0x18  // Common I2C address for LIS3DH

// Sensitivity settings
#define ACCEL_THRESHOLD 0.1  // Deadzone for accelerometer
#define MOUSE_SPEED 2.0      // Mouse movement sensitivity
#define DEBOUNCE_DELAY 50    // Button debounce in ms

// State variables
struct AxisState {
  float x, y, z;
  float prevX, prevY, prevZ;
  bool active;
  unsigned long lastUpdate;
};

AxisState rotationState;
AxisState panState;
bool zoomMode = false;
bool resetMode = false;
bool modeActive = false;

// Button states
bool lastRotateState = HIGH;
bool lastPanState = HIGH;
bool lastZoomState = HIGH;
bool lastResetState = HIGH;
bool lastModeState = HIGH;

unsigned long lastDebounceTime = 0;

BleMouse bleMouse("cADmOTE", "3D CAD Controller", 100);

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 5000) {
    delay(10);
  }
  
  // Initialize I2C
  Wire.begin(ACCEL_SDA, ACCEL_SCL);
  Wire.setClock(400000); // Fast I2C
  
  // Initialize buttons
  pinMode(BTN_ROTATE, INPUT_PULLUP);
  pinMode(BTN_PAN, INPUT_PULLUP);
  pinMode(BTN_ZOOM, INPUT_PULLUP);
  pinMode(BTN_RESET, INPUT_PULLUP);
  pinMode(BTN_MODE, INPUT_PULLUP);
  
  // Initialize BLE Mouse
  bleMouse.begin();
  Serial.println("cADmOTE initialized!");
  
  // Initialize accelerometer
  if (initAccelerometer()) {
    Serial.println("Accelerometer initialized");
  } else {
    Serial.println("Failed to initialize accelerometer!");
  }
  
  // Initialize states
  rotationState.active = false;
  panState.active = false;
  rotationState.lastUpdate = millis();
  panState.lastUpdate = millis();
}

void loop() {
  if (bleMouse.isConnected()) {
    handleButtons();
    handleAccelerometer();
  }
  
  delay(10); // Small delay for stability
}

bool initAccelerometer() {
  // Wake up LIS3DH
  Wire.beginTransmission(ACCEL_ADDR);
  Wire.write(0x20); // CTRL_REG1
  Wire.write(0x57); // 100Hz, all axes enabled
  if (Wire.endTransmission() != 0) return false;
  
  // Set range to ±2g
  Wire.beginTransmission(ACCEL_ADDR);
  Wire.write(0x23); // CTRL_REG4
  Wire.write(0x00); // ±2g
  return Wire.endTransmission() == 0;
}

void readAccelerometer(AxisState& state) {
  Wire.beginTransmission(ACCEL_ADDR);
  Wire.write(0x28); // OUT_X_L
  if (Wire.endTransmission() != 0) return;
  
  Wire.requestFrom(ACCEL_ADDR, 6);
  if (Wire.available() == 6) {
    int16_t x = Wire.read() | (Wire.read() << 8);
    int16_t y = Wire.read() | (Wire.read() << 8);
    int16_t z = Wire.read() | (Wire.read() << 8);
    
    // Convert to g (for ±2g range, 16-bit)
    state.x = x / 16384.0;
    state.y = y / 16384.0;
    state.z = z / 16384.0;
  }
}

void handleAccelerometer() {
  AxisState currentState;
  readAccelerometer(currentState);
  
  if (!currentState.x && !currentState.y && !currentState.z) return;
  
  unsigned long currentTime = millis();
  
  if (rotationState.active) {
    handleRotation(currentState, rotationState, currentTime);
  }
  
  if (panState.active) {
    handlePan(currentState, panState, currentTime);
  }
  
  // Update previous values for next iteration
  if (currentTime - rotationState.lastUpdate > 50) {
    rotationState.prevX = currentState.x;
    rotationState.prevY = currentState.y;
    rotationState.prevZ = currentState.z;
    rotationState.lastUpdate = currentTime;
  }
}

void handleRotation(const AxisState& current, AxisState& state, unsigned long currentTime) {
  // Calculate rotation deltas (gyro-like behavior from accel differences)
  float deltaX = (current.x - state.prevX) * MOUSE_SPEED;
  float deltaY = (current.y - state.prevY) * MOUSE_SPEED;
  float deltaZ = (current.z - state.prevZ) * MOUSE_SPEED;
  
  // Apply deadzone
  if (abs(deltaX) < ACCEL_THRESHOLD) deltaX = 0;
  if (abs(deltaY) < ACCEL_THRESHOLD) deltaY = 0;
  if (abs(deltaZ) < ACCEL_THRESHOLD) deltaZ = 0;
  
  // Map to mouse movement (rotation typically uses X/Y for orbit)
  if (abs(deltaX) > 0 || abs(deltaY) > 0) {
    bleMouse.move(deltaX * 10, -deltaY * 10, 0);
  }
  
  // Z-axis for roll or additional rotation
  if (abs(deltaZ) > ACCEL_THRESHOLD * 1.5) {
    // Could map to scroll or special function
    bleMouse.move(0, 0, deltaZ * 5);
  }
}

void handlePan(const AxisState& current, AxisState& state, unsigned long currentTime) {
  // Pan uses absolute accelerometer values (tilt to pan)
  float panX = (current.x + 1.0) * 50; // Normalize -1 to 1 -> 0 to 100
  float panY = (current.y + 1.0) * 50;
  
  // Apply deadzone around center
  if (abs(current.x) < ACCEL_THRESHOLD) panX = 50;
  if (abs(current.y) < ACCEL_THRESHOLD) panY = 50;
  
  // Map to mouse movement
  int mouseX = constrain((int)(panX - 50), -10, 10);
  int mouseY = constrain((int)(panY - 50), -10, 10);
  
  if (abs(mouseX) > 1 || abs(mouseY) > 1) {
    bleMouse.move(mouseX, mouseY, 0);
  }
}

void handleButtons() {
  unsigned long currentTime = millis();
  
  // Rotate button (hold to activate rotation mode)
  bool rotateState = digitalRead(BTN_ROTATE);
  if (rotateState != lastRotateState) {
    if (currentTime - lastDebounceTime > DEBOUNCE_DELAY) {
      if (rotateState == LOW) {
        rotationState.active = !rotationState.active;
        panState.active = false; // Disable pan when rotating
        Serial.println(rotationState.active ? "Rotation mode ON" : "Rotation mode OFF");
      }
      lastDebounceTime = currentTime;
    }
    lastRotateState = rotateState;
  }
  
  // Pan button (hold to activate pan mode)
  bool panStateBtn = digitalRead(BTN_PAN);
  if (panStateBtn != lastPanState) {
    if (currentTime - lastDebounceTime > DEBOUNCE_DELAY) {
      if (panStateBtn == LOW) {
        panState.active = !panState.active;
        rotationState.active = false; // Disable rotation when panning
        Serial.println(panState.active ? "Pan mode ON" : "Pan mode OFF");
      }
      lastDebounceTime = currentTime;
    }
    lastPanState = panStateBtn;
  }
  
  // Zoom button
  bool zoomState = digitalRead(BTN_ZOOM);
  if (zoomState == LOW && lastZoomState == HIGH) {
    // Send scroll event for zoom
    bleMouse.move(0, 0, zoomMode ? -5 : 5);
    zoomMode = !zoomMode;
    Serial.println(zoomMode ? "Zoom IN" : "Zoom OUT");
  }
  lastZoomState = zoomState;
  
  // Reset button (center view)
  bool resetState = digitalRead(BTN_RESET);
  if (resetState == LOW && lastResetState == HIGH) {
    // Send special reset command (could be Ctrl+Home or similar)
    bleMouse.click(MOUSE_LEFT);
    delay(50);
    bleMouse.press(MOUSE_LEFT);
    delay(50);
    bleMouse.release(MOUSE_LEFT);
    Serial.println("Reset view");
  }
  lastResetState = resetState;
  
  // Mode button (cycle through modes or special functions)
  bool modeState = digitalRead(BTN_MODE);
  if (modeState == LOW && lastModeState == HIGH) {
    cycleMode();
    lastDebounceTime = currentTime;
  }
  lastModeState = modeState;
}

void cycleMode() {
  static int currentMode = 0;
  const char* modes[] = {"CAD Mode", "Game Mode", "Presentation Mode"};
  
  currentMode = (currentMode + 1) % 3;
  
  switch (currentMode) {
    case 0: // CAD Mode
      MOUSE_SPEED = 2.0;
      Serial.println("Mode: CAD - Precision control");
      break;
    case 1: // Game Mode  
      MOUSE_SPEED = 5.0;
      Serial.println("Mode: Game - Fast control");
      break;
    case 2: // Presentation Mode
      MOUSE_SPEED = 1.0;
      Serial.println("Mode: Presentation - Smooth control");
      break;
  }
}

// Optional: Add calibration function
void calibrateAccelerometer() {
  Serial.println("Calibrating accelerometer... Keep device still!");
  delay(2000);
  
  float sumX = 0, sumY = 0, sumZ = 0;
  int samples = 100;
  
  for (int i = 0; i < samples; i++) {
    AxisState temp;
    readAccelerometer(temp);
    sumX += temp.x;
    sumY += temp.y;
    sumZ += temp.z;
    delay(10);
  }
  
  // Store calibration offsets (you'd want to save these to EEPROM)
  // For now, just print them
  Serial.print("Calibration offsets - X: ");
  Serial.print(sumX / samples);
  Serial.print(" Y: ");
  Serial.print(sumY / samples);
  Serial.print(" Z: ");
  Serial.println(sumZ / samples);
}
